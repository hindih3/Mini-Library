// Imitation of the STL vector, dynamic random-access array
// First completed 12/30/25


#pragma once
#include <iterator>
#include <cstddef>
#include <stdexcept>
#include <initializer_list>
#include <utility>

namespace mini {

    template <class T>
    class vector {
    public:
        class iterator {
        public:
            using iterator_category = std::random_access_iterator_tag;
            using value_type = T;
            using difference_type = std::ptrdiff_t;
            using pointer = T*;
            using reference = T&;

            iterator(T* ptr = nullptr) noexcept : m_ptr(ptr) {}
            ~iterator() noexcept = default;

            reference operator*() const noexcept { return *m_ptr; }
            pointer   operator->() const { return m_ptr; }
            reference operator[](difference_type n) const noexcept { return m_ptr[n]; }

            iterator& operator++() noexcept { ++m_ptr; return *this; }
            iterator  operator++(int) noexcept { iterator tmp = *this; ++(*this); return tmp; }

            iterator& operator--() noexcept { --m_ptr; return *this; }
            iterator  operator--(int) noexcept { iterator tmp = *this; --(*this); return tmp; }

            iterator& operator+=(difference_type n) noexcept { m_ptr += n; return *this; }
            iterator& operator-=(difference_type n) noexcept { m_ptr -= n; return *this; }

            iterator operator+(difference_type n) const noexcept { return iterator(m_ptr + n); }
            iterator operator-(difference_type n) const noexcept { return iterator(m_ptr - n); }

            difference_type operator-(const iterator& other) const noexcept {
                return m_ptr - other.m_ptr;
            }

            bool operator==(const iterator& other) const noexcept { return m_ptr == other.m_ptr; }
            bool operator!=(const iterator& other) const noexcept { return m_ptr != other.m_ptr; }
            bool operator<(const iterator& other) const noexcept { return m_ptr < other.m_ptr; }
            bool operator>(const iterator& other) const noexcept { return m_ptr > other.m_ptr; }
            bool operator<=(const iterator& other) const noexcept { return m_ptr <= other.m_ptr; }
            bool operator>=(const iterator& other) const noexcept { return m_ptr >= other.m_ptr; }

        private:
            T* m_ptr;
        };
        class const_iterator {
        public:
            using iterator_category = std::random_access_iterator_tag;
            using value_type = T;
            using difference_type = std::ptrdiff_t;
            using pointer = const T*;
            using reference = const T&;

            const_iterator(const T* ptr = nullptr) noexcept : m_ptr(ptr) {}
            const_iterator(const iterator& it) noexcept : m_ptr(it.operator->()) {}

            reference operator*() const noexcept { return *m_ptr; }
            pointer   operator->() const { return m_ptr; }
            reference operator[](difference_type n) const noexcept { return m_ptr[n]; }

            const_iterator& operator++() noexcept { ++m_ptr; return *this; }
            const_iterator operator++(int) noexcept {
                const_iterator tmp = *this;
                ++(*this);
                return tmp;
            }

            const_iterator& operator--() noexcept { --m_ptr; return *this; }
            const_iterator operator--(int) noexcept {
                const_iterator tmp = *this;
                --(*this);
                return tmp;
            }

            const_iterator& operator+=(difference_type n) noexcept { m_ptr += n; return *this; }
            const_iterator& operator-=(difference_type n) noexcept { m_ptr -= n; return *this; }

            const_iterator operator+(difference_type n) const noexcept {
                return const_iterator(m_ptr + n);
            }

            const_iterator operator-(difference_type n) const noexcept {
                return const_iterator(m_ptr - n);
            }

            difference_type operator-(const const_iterator& other) const noexcept {
                return m_ptr - other.m_ptr;
            }

            bool operator==(const const_iterator& other) const noexcept { return m_ptr == other.m_ptr; }
            bool operator!=(const const_iterator& other) const noexcept { return m_ptr != other.m_ptr; }
            bool operator<(const const_iterator& other) const noexcept { return m_ptr < other.m_ptr; }
            bool operator>(const const_iterator& other) const noexcept { return m_ptr > other.m_ptr; }
            bool operator<=(const const_iterator& other) const noexcept { return m_ptr <= other.m_ptr; }
            bool operator>=(const const_iterator& other) const noexcept { return m_ptr >= other.m_ptr; }

        private:
            const T* m_ptr;
        };

        explicit vector(size_t size = 0) : //default constructor
            m_capacity(size),
            m_size(size),
            m_data(size == 0 ? nullptr : static_cast<T*>(::operator new(sizeof(T) * size)))
        {
            for (size_t i = 0; i < size; ++i)
                new (m_data + i) T();
        }

        vector(const vector& other) : //copy constuctor
            m_capacity(other.m_capacity),
            m_size(other.m_size),
            m_data(other.m_capacity == 0 ? nullptr : static_cast<T*>(::operator new(sizeof(T) * other.m_capacity)))
        {
            for (size_t i = 0; i < other.m_size; ++i)
                new (m_data + i) T(other.m_data[i]);
        }

        vector(vector&& other) noexcept : // move constructor
            m_data(other.m_data),
            m_size(other.m_size),
            m_capacity(other.m_capacity)
        {
            other.m_data = nullptr;
            other.m_size = 0;
            other.m_capacity = 0;
        }

        vector& operator=(const vector& other) { // copy assignment operator
            if (this == &other)
                return *this;

            T* new_data = other.m_capacity == 0 ? nullptr : static_cast<T*>(::operator new(sizeof(T) * other.m_capacity));

            size_t i = 0;
            try {
                for (; i < other.m_size; ++i)
                    new (new_data + i) T(other.m_data[i]);
            }
            catch (...) {
                for (size_t j = 0; j < i; ++j)
                    new_data[j].~T();
                ::operator delete(new_data);
                throw;
            }

            for (i = 0; i < m_size; ++i)
                m_data[i].~T();
            ::operator delete(m_data);

            m_data = new_data;
            m_size = other.m_size;
            m_capacity = other.m_capacity;

            return *this;
        }

        vector& operator=(vector&& other) noexcept { //move assignment operator
            if (this == &other)
                return *this;

            for (size_t i = 0; i < m_size; ++i)
                m_data[i].~T();
            ::operator delete(m_data);

            m_data = other.m_data;
            m_capacity = other.m_capacity;
            m_size = other.m_size;

            other.m_data = nullptr;
            other.m_capacity = 0;
            other.m_size = 0;
            return *this;
        }

        vector(std::initializer_list<T> init) :
            m_capacity(init.size()), m_size(init.size()),
            m_data(init.size() == 0 ? nullptr : static_cast<T*>(::operator new(sizeof(T) * init.size())))
        {
            size_t i = 0;
            try {
                for (const T& value : init) {
                    new (m_data + i) T(value);
                    ++i;
                }
            }
            catch (...) {
                for (size_t j = 0; j < i; ++j)
                    m_data[j].~T();
                ::operator delete(m_data);
                throw;
            }
        }

        ~vector() { //destructor
            for (size_t i = 0; i < m_size; ++i)
                m_data[i].~T();
            ::operator delete(m_data);
        }

        void reserve(size_t new_capacity) {
            if (new_capacity <= m_capacity)
                return;

            T* new_data = static_cast<T*>(::operator new(sizeof(T) * new_capacity));

            size_t i = 0;
            try {
                for (; i < m_size; ++i)
                    new (new_data + i) T(std::move_if_noexcept(m_data[i]));
            }
            catch (...) {
                for (size_t j = 0; j < i; ++j)
                    new_data[j].~T();
                ::operator delete(new_data);
                throw;
            }

            for (i = 0; i < m_size; ++i) m_data[i].~T();
            ::operator delete(m_data);

            m_data = new_data;
            m_capacity = new_capacity;
        }

        void resize(size_t new_size) {
            if (new_size > m_capacity)
                reserve(new_size);

            if (new_size > m_size) {
                size_t i = m_size;
                try {
                    for (; i < new_size; ++i)
                        new (m_data + i) T();
                }
                catch (...) {
                    for (size_t j = m_size; j < i; ++j) m_data[j].~T();
                    throw;
                }
            }

            else {
                for (size_t i = new_size; i < m_size; ++i)
                    m_data[i].~T();
            }
            m_size = new_size;
        }

        void shrink_to_fit() {
            T* new_data = m_size == 0 ? nullptr : static_cast<T*>(::operator new(sizeof(T) * m_size));

            size_t i = 0;
            try {
                for (; i < m_size; ++i)
                    new (new_data + i) T(std::move_if_noexcept(m_data[i]));
            }
            catch (...) {
                for (size_t j = 0; j < i; ++j)
                    new_data[j].~T();
                ::operator delete(new_data);
                throw;
            }

            for (i = 0; i < m_size; ++i) m_data[i].~T();
            ::operator delete(m_data);
            m_data = new_data;
            m_capacity = m_size;
        }

        void push_back(const T& value) {
            if (m_size >= m_capacity)
                reserve(m_capacity == 0 ? 1 : m_capacity * 2);

            new (m_data + m_size) T(value);
            ++m_size;
        }

        void push_back(T&& value) {
            if (m_size >= m_capacity)
                reserve(m_capacity == 0 ? 1 : m_capacity * 2);

            new (m_data + m_size) T(std::move(value));
            ++m_size;
        }

        void pop_back() {
            if (m_size == 0)
                throw std::out_of_range("Index out of range!");
            m_size--;
            m_data[m_size].~T();
        }
        
        void insert(size_t index, const T& value) {
            if (index > m_size)
                throw std::out_of_range("Index out of range");

            if (m_size >= m_capacity) {
                size_t new_capacity = m_capacity == 0 ? 1 : m_capacity * 2;
                reserve(new_capacity);
            }

            size_t i = m_size;
            try {
                for (; i > index; --i) {
                    new (m_data + i) T(std::move(m_data[i - 1]));
                    m_data[i - 1].~T();
                }
            }
            catch (...) {
                for (size_t j = i; j < m_size; ++j)
                    m_data[j].~T();
                throw;
            }

            new (m_data + index) T(value);
            ++m_size;
        }

        void insert(size_t index, T&& value) {
            if (index > m_size)
                throw std::out_of_range("Index out of range");

            if (m_size >= m_capacity) {
                size_t new_capacity = m_capacity == 0 ? 1 : m_capacity * 2;
                reserve(new_capacity);
            }

            size_t i = m_size;
            try {
                for (; i > index; --i) {
                    new (m_data + i) T(std::move(m_data[i - 1]));
                    m_data[i - 1].~T();
                }

            }
            catch (...) {
                for (size_t j = i; j < m_size; ++j)
                    m_data[j].~T();
                throw;
            }

            new (m_data + index) T(std::move(value));
            ++m_size;
        }

        void erase(size_t index) {
            if (index >= m_size)
                throw std::out_of_range("Index out of range");

            m_data[index].~T();

            size_t i = index;
            try {
                for (; i + 1 < m_size; ++i) {
                    new (m_data + i) T(std::move(m_data[i + 1]));
                    m_data[i + 1].~T();
                }
            }
            catch (...) {
                for (size_t j = index; j < i; ++j)
                    m_data[j].~T();
                throw;
            }

            --m_size;
        }

        void clear() {
            for (size_t i = 0; i < m_size; ++i) {
                m_data[i].~T();
            }

            m_size = 0;
        }

        bool empty() const noexcept { return m_size == 0; }

        T& operator[](size_t index) noexcept {
            return m_data[index];
        }

        const T& operator[](size_t index) const noexcept {
            return m_data[index];
        }

        T& at(size_t index) {
            if (index >= m_size)
                throw std::out_of_range("Index out of range");

            return m_data[index];
        }

        const T& at(size_t index) const {
            if (index >= m_size)
                throw std::out_of_range("Index out of range");

            return m_data[index];
        }

        size_t size() const noexcept { return m_size; }
        size_t capacity() const noexcept { return m_capacity; }


        iterator begin() noexcept { return iterator(m_data); }
        iterator end()   noexcept { return iterator(m_data + m_size); }

        const_iterator begin() const noexcept { return const_iterator(m_data); }
        const_iterator end()   const noexcept { return const_iterator(m_data + m_size); }

        const_iterator cbegin() const noexcept { return const_iterator(m_data); }
        const_iterator cend()   const noexcept { return const_iterator(m_data + m_size); }

        T* data() noexcept { return m_data; }
        const T* data() const noexcept { return m_data; }
    private:

        T* m_data;
        size_t m_size;
        size_t m_capacity;
    };
}
