#pragma once
#include <iterator>
#include <cstddef>
#include <stdexcept>
#include <initializer_list>
#include <utility>
#include "memory.h"

namespace mini {

    template <class T>
    class vector {
    public:
        class iterator {
        public:
            using iterator_category = std::random_access_iterator_tag;
            using value_type = T;
            using difference_type = std::ptrdiff_t;
            using pointer = T*;
            using reference = T&;

            iterator(T* ptr = nullptr) noexcept : m_ptr(ptr) {}
            ~iterator() noexcept = default;

            reference operator*() const noexcept { return *m_ptr; }
            pointer   operator->() const { return m_ptr; }
            reference operator[](difference_type n) const noexcept { return m_ptr[n]; }

            iterator& operator++() noexcept { ++m_ptr; return *this; }
            iterator  operator++(int) noexcept { iterator tmp = *this; ++(*this); return tmp; }

            iterator& operator--() noexcept { --m_ptr; return *this; }
            iterator  operator--(int) noexcept { iterator tmp = *this; --(*this); return tmp; }

            iterator& operator+=(difference_type n) noexcept { m_ptr += n; return *this; }
            iterator& operator-=(difference_type n) noexcept { m_ptr -= n; return *this; }

            iterator operator+(difference_type n) const noexcept { return iterator(m_ptr + n); }
            iterator operator-(difference_type n) const noexcept { return iterator(m_ptr - n); }

            difference_type operator-(const iterator& other) const noexcept {
                return m_ptr - other.m_ptr;
            }

            bool operator==(const iterator& other) const noexcept { return m_ptr == other.m_ptr; }
            bool operator!=(const iterator& other) const noexcept { return m_ptr != other.m_ptr; }
            bool operator<(const iterator& other) const noexcept { return m_ptr < other.m_ptr; }
            bool operator>(const iterator& other) const noexcept { return m_ptr > other.m_ptr; }
            bool operator<=(const iterator& other) const noexcept { return m_ptr <= other.m_ptr; }
            bool operator>=(const iterator& other) const noexcept { return m_ptr >= other.m_ptr; }

        private:
            T* m_ptr;
        };
        class const_iterator {
        public:
            using iterator_category = std::random_access_iterator_tag;
            using value_type = const T;
            using difference_type = std::ptrdiff_t;
            using pointer = const T*;
            using reference = const T&;

            const_iterator(const T* ptr = nullptr) noexcept : m_ptr(ptr) {}
            const_iterator(const iterator& it) noexcept : m_ptr(it.operator->()) {}

            reference operator*() const noexcept { return *m_ptr; }
            pointer   operator->() const { return m_ptr; }
            reference operator[](difference_type n) const noexcept { return m_ptr[n]; }

            const_iterator& operator++() noexcept { ++m_ptr; return *this; }
            const_iterator operator++(int) noexcept {
                const_iterator tmp = *this;
                ++(*this);
                return tmp;
            }

            const_iterator& operator--() noexcept { --m_ptr; return *this; }
            const_iterator operator--(int) noexcept {
                const_iterator tmp = *this;
                --(*this);
                return tmp;
            }

            const_iterator& operator+=(difference_type n) noexcept { m_ptr += n; return *this; }
            const_iterator& operator-=(difference_type n) noexcept { m_ptr -= n; return *this; }

            const_iterator operator+(difference_type n) const noexcept {
                return const_iterator(m_ptr + n);
            }

            const_iterator operator-(difference_type n) const noexcept {
                return const_iterator(m_ptr - n);
            }

            difference_type operator-(const const_iterator& other) const noexcept {
                return m_ptr - other.m_ptr;
            }

            bool operator==(const const_iterator& other) const noexcept { return m_ptr == other.m_ptr; }
            bool operator!=(const const_iterator& other) const noexcept { return m_ptr != other.m_ptr; }
            bool operator<(const const_iterator& other) const noexcept { return m_ptr < other.m_ptr; }
            bool operator>(const const_iterator& other) const noexcept { return m_ptr > other.m_ptr; }
            bool operator<=(const const_iterator& other) const noexcept { return m_ptr <= other.m_ptr; }
            bool operator>=(const const_iterator& other) const noexcept { return m_ptr >= other.m_ptr; }

        private:
            const T* m_ptr;
        };

        explicit vector(size_t size = 0) :
            m_capacity(size),
            m_size(size),
            m_data(mini::allocate<T>(size))
        {
            for (size_t i = 0; i < size; ++i)
                mini::construct<T>(m_data + i);
        }

        vector(const vector& other) :
            m_capacity(other.m_capacity),
            m_size(other.m_size),
            m_data(mini::allocate<T>(other.m_capacity))
        {
            size_t i = 0;
            try {
                for (; i < other.m_size; ++i)
                    mini::construct<T>(m_data + i, other.m_data[i]);
            }
            catch (...) {
                mini::destroy<T>(m_data, m_data + i);
                mini::deallocate<T>(m_data);
                throw;
            }
        }

        vector(vector&& other) noexcept :
            m_data(other.m_data),
            m_size(other.m_size),
            m_capacity(other.m_capacity)
        {
            other.m_data = nullptr;
            other.m_size = 0;
            other.m_capacity = 0;
        }

        vector& operator=(const vector& other) {
            if (this == &other)
                return *this;

            T* new_data = mini::allocate<T>(other.m_capacity);

            size_t i = 0;
            try {
                for (; i < other.m_size; ++i)
                    mini::construct<T>(new_data + i, other.m_data[i]);
            }
            catch (...) {
                mini::destroy<T>(new_data, new_data + i);
                mini::deallocate<T>(new_data);
                throw;
            }

            mini::destroy<T>(m_data, m_data + m_size);
            mini::deallocate<T>(m_data);

            m_data = new_data;
            m_size = other.m_size;
            m_capacity = other.m_capacity;

            return *this;
        }

        vector& operator=(vector&& other) noexcept {
            if (this == &other)
                return *this;

            mini::destroy<T>(m_data, m_data + m_size);
            mini::deallocate<T>(m_data);

            m_data = other.m_data;
            m_capacity = other.m_capacity;
            m_size = other.m_size;

            other.m_data = nullptr;
            other.m_capacity = 0;
            other.m_size = 0;
            return *this;
        }

        vector(std::initializer_list<T> init) :
            m_capacity(init.size()), m_size(init.size()),
            m_data(mini::allocate<T>(init.size()))
        {
            size_t i = 0;
            try {
                for (auto&& value : init) {
                    mini::construct<T>(m_data + i, value);
                    ++i;
                }
            }
            catch (...) {
                mini::destroy<T>(m_data, m_data + i);
                mini::deallocate<T>(m_data);
                throw;
            }
        }

        ~vector() {
            mini::destroy<T>(m_data, m_data + m_size);
            mini::deallocate<T>(m_data);
        }

        void reserve(size_t new_capacity) {
            if (new_capacity <= m_capacity)
                return;

            T* new_data = mini::allocate<T>(new_capacity);

            size_t i = 0;
            try {
                for (; i < m_size; ++i)
                    mini::construct<T>(new_data + i, std::move_if_noexcept(m_data[i]));
            }
            catch (...) {
                mini::destroy<T>(new_data, new_data + i);
                mini::deallocate<T>(new_data);
                throw;
            }

            mini::destroy<T>(m_data, m_data + m_size);
            mini::deallocate<T>(m_data);
            m_data = new_data;
            m_capacity = new_capacity;
        }

        void resize(size_t new_size) {
            if (new_size > m_capacity)
                reserve(new_size);

            if (new_size > m_size) {
                size_t i = m_size;
                try {
                    for (; i < new_size; ++i)
                        mini::construct<T>(m_data + i);
                }
                catch (...) {
                    mini::destroy<T>(m_data + m_size, m_data + i);
                    throw;
                }
            } else {
                mini::destroy<T>(m_data + new_size, m_data + m_size);
            }
            m_size = new_size;
        }

        void shrink_to_fit() {
            T* new_data = mini::allocate<T>(m_size);

            size_t i = 0;
            try {
                for (; i < m_size; ++i)
                    mini::construct<T>(new_data + i, std::move_if_noexcept(m_data[i]));
            }
            catch (...) {
                mini::destroy<T>(new_data, new_data + i);
                mini::deallocate<T>(new_data);
                throw;
            }

            mini::destroy<T>(m_data, m_data + m_size);
            mini::deallocate<T>(m_data);
            m_data = new_data;
            m_capacity = m_size;
        }

        void push_back(const T& value) {
            if (m_size >= m_capacity)
                reserve(m_capacity == 0 ? 1 : m_capacity * growth_factor);

            mini::construct<T>(m_data + m_size, value);
            ++m_size;
        }

        void push_back(T&& value) {
            if (m_size >= m_capacity)
                reserve(m_capacity == 0 ? 1 : m_capacity * growth_factor);

            mini::construct<T>(m_data + m_size, std::move(value));
            ++m_size;
        }

        void pop_back() {
            if (m_size == 0)
                throw std::out_of_range("Index out of range!");
            --m_size;
            mini::destroy<T>(m_data + m_size);
        }

        void insert(size_t index, const T& value) {
            if (index > m_size)
                throw std::out_of_range("Index out of range");

            if (m_size >= m_capacity)
                reserve(m_capacity == 0 ? 1 : m_capacity * growth_factor);

            if (index == m_size)
                mini::construct<T>(m_data + m_size, value);
            else {
                mini::construct<T>(m_data + m_size, std::move_if_noexcept(m_data[m_size - 1]));

                for (size_t i = m_size - 1; i > index; --i)
                    m_data[i] = std::move_if_noexcept(m_data[i - 1]);

                m_data[index] = value;
            }

            ++m_size;
        }

        void insert(size_t index, T&& value) {
            if (index > m_size)
                throw std::out_of_range("Index out of range");

            if (m_size >= m_capacity)
                reserve(m_capacity == 0 ? 1 : m_capacity * growth_factor);

            if (index == m_size) {
                mini::construct<T>(m_data + m_size, std::move(value));
            } else {
                mini::construct<T>(
                    m_data + m_size,
                    std::move_if_noexcept(m_data[m_size - 1])
                );

                for (size_t i = m_size - 1; i > index; --i)
                    m_data[i] = std::move_if_noexcept(m_data[i - 1]);

                m_data[index] = std::move(value);
            }

            ++m_size;
        }

        void safe_insert(size_t index, const T& value) {
            if (index > m_size)
                throw std::out_of_range("Index out of range");

            vector temp(*this);
            temp.insert(index, value);
            *this = temp;
        }
    
        //basic exception safety on erase
        void erase(size_t index) {
            if (index >= m_size)
                throw std::out_of_range("Index out of range");

            for (size_t i = index; i + 1 < m_size; ++i)
                m_data[i] = std::move(m_data[i + 1]);

            mini::destroy<T>(m_data + m_size - 1);
            --m_size;
        }

        void clear() {
            mini::destroy<T>(m_data, m_data + m_size);
            m_size = 0;
        }

        bool empty() const noexcept { return m_size == 0; }

        T& operator[](size_t index) noexcept { return m_data[index]; }
        const T& operator[](size_t index) const noexcept { return m_data[index]; }

        T& at(size_t index) {
            if (index >= m_size)
                throw std::out_of_range("Index out of range");
            return m_data[index];
        }

        const T& at(size_t index) const {
            if (index >= m_size)
                throw std::out_of_range("Index out of range");
            return m_data[index];
        }

        size_t size() const noexcept { return m_size; }
        size_t capacity() const noexcept { return m_capacity; }

        iterator begin() noexcept { return iterator(m_data); }
        iterator end()   noexcept { return iterator(m_data + m_size); }

        const_iterator begin() const noexcept { return const_iterator(m_data); }
        const_iterator end()   const noexcept { return const_iterator(m_data + m_size); }

        const_iterator cbegin() const noexcept { return const_iterator(m_data); }
        const_iterator cend()   const noexcept { return const_iterator(m_data + m_size); }

        T* data() noexcept { return m_data; }
        const T* data() const noexcept { return m_data; }

    private:
        T* m_data;
        size_t m_size;
        size_t m_capacity;
        const size_t growth_factor = 2;
    };
}
